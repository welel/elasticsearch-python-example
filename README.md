# ElasticSearch + Python

- **kibana_script** - описание работы ElasticSearch в виде скрипта с комментариями для консоли Kibana
- **elastic.py** - описание некоторых запросов к ElasticSearch из Python
- **etl.py** - пример ETL операции PostgreSQL -> ElasticSearch

**Elasticsearch** — это документо-ориентированная система управления базами данных, которая обеспечивает быстрый поиск, фильтрацию и сортировку данных. Она использует JSON-формат для хранения документов и предоставляет мощные возможности для полнотекстового поиска и аналитики данных в режиме близком к реальному времени.

Запросы и ответы к Elasticsearch осуществляются по **RESTful API**. Для операций с данными, настройки и управления кластером, используются стандартные HTTP запросы. Elasticsearch возвращает ответы в формате JSON. В ответе содержится информация о статусе выполнения запроса, а также запрошенные данные или подробное описание ошибки, если запрос не был выполнен успешно.


#### Вывод списка индексов
```
GET /_cat/indices/<index_name (optional)>/
```
Индексы, начинающиеся с точки, создаются автоматически системой. В отчёте удобно смотреть наличие индексов и занимаемый ими размер на диске, или просто проверять, что соединение с ElasticSearch установлено.

**Запрос:**
```json
GET /_cat/indices
```

**Ответ:**
```
green ... .geoip_databases   g... ...  40.7mb
green ... .security-7        q... ... 213.7kb
green ... .apm-custom-link   O... ...    227b
green ... .kibana-event-log- O... ...  32.7kb
green ... .apm-agent-configu 0... ...    227b
green ... .kibana_7.13.4_001 W... ...   4.3mb
green ... .kibana_task_manag X... ...   1.2mb
green ... .tasks             -... ...  62.2kb
```
В первом столбце отображается health индекса, в третьем - название индекса, в последнем - размер, занимаемый на диске.

#### Создание индекса
```
PUT /<index_name>
{<body>}
```
В **setting** указывается количество шардов и реплик, по умолчанию создается 1 шард и 1 реплика. Если в кластере всего одна машина с одной нодой ElasticSearch, то создавать реплики нет смысла, так как ElasticSearch всё равно не создаст их на одной ноде. Создание множества шардов особо не повлияет на производительность. 
Подробнее об этом: https://stackoverflow.com/questions/15694724/shards-and-replicas-in-elasticsearch

Параметр **properties** задает структуру документа - названия полей, их типы и другие настройки.

ElasticSearch имеет большое количество различных типов, включая все основные базовые типы.
Документация о типах: https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html

**Запрос:**
```json
PUT /user
{
  "settings": {
    "number_of_shards": 2,
    "number_of_replicas": 0
  },
  "mappings": {
    "properties": {
      "name": {
        "type": "text"
      },
      "age": {
        "type": "integer"
      },
      "created_at": {
        "type": "date"
      }
    }
  }
}
```

**Успешный ответ:**
```json
{
  "acknowledged" : true,
  "shards_acknowledged" : true,
  "index" : "user"
}
```

Если попытаться создать уже существующий индекс, то возникнет ошибка. Ошибка тоже имеет формат JSON и достаточно информации, чтобы понять в чём проблема.

**Ответ с инфорацией об ошибке:**
```json
{
  "error" : {
    "root_cause" : [
      {
        "type" : "resource_already_exists_exception",
        "reason" : "index [user/mYG1G6McTZ2OVqXQSlfrVA] already exists",
        "index_uuid" : "mYG1G6McTZ2OVqXQSlfrVA",
        "index" : "user"
      }
    ],
    "type" : "resource_already_exists_exception",
    "reason" : "index [user/mYG1G6McTZ2OVqXQSlfrVA] already exists",
    "index_uuid" : "mYG1G6McTZ2OVqXQSlfrVA",
    "index" : "user"
  },
  "status" : 400
}
```
#### Вывод информации об индексе

- `GET /<index_name>` - общая информация;
- `GET /<index_name>/_mapping` - структура документа;
- `GET /<index_name>/_stats` - обширная информация (есть размер индекса).

**Запросы:**
```json
GET /user
GET /user/_mapping
GET /user/_stats
```

#### Добавление документа в индекс
```
POST /<index_name>/_doc/<doc_id (optional)>
{<doc>}
```

**Запрос:**
```json
POST /user/_doc/1
{
  "name": "John Doe",
  "age": 30,
  "created_at": "2000-01-01T00:00:00"
}
```

**Ответ:**
```json
{
  "_index" : "user",
  "_type" : "_doc",
  "_id" : "1",
  "_version" : 1,
  "result" : "created",
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "failed" : 0
  },
  "_seq_no" : 0,
  "_primary_term" : 1
}
```

В ответе видим **\_version** - версия документа, инкрементируется при обновлении. **result** - название операции, которая была произведена с документом. При первом добавлении в result выводится **created**. Если мы выполним запрос второй раз, то увеличится значение \_version на 1, и result будет **updated**.

Таким образом понимаем, что данный запрос не только добавляет новый документ, но также и обновляет его. Но для обновления необходимо передать полный документ (со всеми полями).

В ElasticSearch есть операции **create** (создание документа, если нет в индексе, иначе ошибка); **update** (обновление документа, если он в индексе, иначе ошибка), **index** (выбор между create и update в зависимости от наличия документа в индексе). В Python названия операций соответствуют названиям методов, и там удобнее всего использовать метод index.

#### Добавление множества докуметов

```shell
POST /<index_name>/_bulk
{<meta>}
{<doc>}
...
```
В **\_bulk** можно передать набор различных операций: create, update, index и т.д. И обращаться к различным индексам в одном запросе.

**Запрос:**
```json
POST /user/_bulk
{"index": {"_index": "user", "_id": "1" }}
{"name": "Kale Smith", "age" : 19, "created_at": "2022-01-01T00:00:00"}
{"index": {"_index": "user", "_id": "2" }}
{"name": "John Blake", "age" : 25, "created_at": "2022-02-01T00:00:00"}
{"index": {"_index": "user", "_id": "3" }}
{"name": "Raul Perez", "age" : 31, "created_at": "2022-03-01T00:00:00"}
{"index": {"_index": "user", "_id": "4" }}
{"name": "Tony Walker", "age" : 44, "created_at": "2022-04-01T00:00:00"}
{"index": {"_index": "user", "_id": "5"}}
{"name": "Justin Blake", "age": 59, "created_at": "2022-05-01T00:00:00"}
```
В первой строчки тела запроса в первом слове **index** указывает название операции. В ответе получим список результатов на каждую операцию. Если некоторые операции выполнились с ошибой, информация об этом будет в списке.

#### Динамическое создание индекса

Если добавить документ в несуществующий индекс, то он автоматически создастся, и подгонит структуру под переданный документ.

На момент выполнения запроса индекса **clients** не существует. При выполнении запросов не возникнет ошибок.

**Запросы:**
```json
POST /clients/_doc/1
{
  "name": "John Smith",
  "age": 19,
  "created_at": "2000-01-01T00:00:00"
}
  
GET /_cat/indices
GET /clients
```

Последняя команда покажет, что индекс уже существует и выведет информацию о структуре документа индекса. Можно будет заметить, 
что ElasticSearch выбирает какие-то типы по-умолчанию, и они в данном случае не оптимальны. Так как полю **age** создан тип **long**, а мы не собираемся хранить там значения более 255, поэтому лучше подойдёт тип **short**. Удобнее создавать индекс автоматически, но для оптимизации, всё же лучше вручную.

#### Динамическая структура документа

Если в документе указать несуществующие поля, то они автоматически добавятся в структуру документа индекса. Добавился **location**, которого до этого не было.

**Запрос:**
```json
POST /clients/_doc/1
{
  "name": "John Smith",
  "age": 19,
  "created_at": "2000-01-01T00:00:00",
  "location": "London"
}

GET /clients/_mapping
```

После выполнения, это поле добавится в структуру документа и индекс.

Динамическое изменение индекса может быть неприятным, если при индексации не сильно обращаем внимание на валидацию передаваемых данных. Для того, чтобы отключить динамическое изменение, необходимо в настройки mapping добавить **"dynamic": false** при создании индекса. При dynamic false несуществующие поля буду игнорироваться.

**Запрос:**
```json
PUT /clients
{
  "settings": {
    "number_of_shards": 1,
    "number_of_replicas": 0
  },
  "mappings": {
    "dynamic": false,
    "properties": {
      "name": {
        "type": "text"
      }
    }
  }
}
```

#### Удаление индекса

```
DELETE /<index_name>
```
С этим запросом необходимо быть осторожным, потому что восстановить данные будет либо очень сложно, либо невозможно. Он удалит индекс и все данные.
```json
DELETE /clients
```
