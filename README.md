# ElasticSearch + Python

- **kibana_script** - описание работы ElasticSearch в виде скрипта с комментариями для консоли Kibana
- **elastic.py** - описание некоторых запросов к ElasticSearch из Python
- **etl.py** - пример ETL операции PostgreSQL -> ElasticSearch



**Elasticsearch** — это документо-ориентированная система управления базами данных, которая обеспечивает быстрый поиск, фильтрацию и сортировку данных. Она использует JSON-формат для хранения документов и предоставляет мощные возможности для полнотекстового поиска и аналитики данных в режиме близком к реальному времени.

Запросы и ответы к Elasticsearch осуществляются по **RESTful API**. Для операций с данными, настройки и управления кластером, используются стандартные HTTP запросы. Elasticsearch возвращает ответы в формате JSON. В ответе содержится информация о статусе выполнения запроса, а также запрошенные данные или подробное описание ошибки, если запрос не был выполнен успешно.


### Вывод списка индексов
```
GET /_cat/indices/<index_name (optional)>/
```
Индексы, начинающиеся с точки, создаются автоматически системой. В отчёте удобно смотреть наличие индексов и занимаемый ими размер на диске, или просто проверять, что соединение с ElasticSearch установлено.

**Запрос:**
```
GET /_cat/indices
```

**Ответ:**
```
green ... .geoip_databases   g... ...  40.7mb
green ... .security-7        q... ... 213.7kb
green ... .apm-custom-link   O... ...    227b
green ... .kibana-event-log- O... ...  32.7kb
green ... .apm-agent-configu 0... ...    227b
green ... .kibana_7.13.4_001 W... ...   4.3mb
green ... .kibana_task_manag X... ...   1.2mb
green ... .tasks             -... ...  62.2kb
```
В первом столбце отображается health индекса, в третьем - название индекса, в последнем - размер, занимаемый на диске.

### Создание индекса
```
PUT /<index_name>
{<body>}
```
В **setting** указывается количество шардов и реплик, по умолчанию создается 1 шард и 1 реплика. Если в кластере всего одна машина с одной нодой ElasticSearch, то создавать реплики нет смысла, так как ElasticSearch всё равно не создаст их на одной ноде. Создание множества шардов особо не повлияет на производительность. 

Подробнее об этом: https://stackoverflow.com/questions/15694724/shards-and-replicas-in-elasticsearch

Параметр **properties** задает структуру документа - названия полей, их типы и другие настройки.

ElasticSearch имеет большое количество различных типов, включая все основные базовые типы.

Документация о типах: https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html

**Запрос:**
```shell
PUT /user
{
  "settings": {
    "number_of_shards": 2,
    "number_of_replicas": 0
  },
  "mappings": {
    "properties": {
      "name": {
        "type": "text"
      },
      "age": {
        "type": "integer"
      },
      "created_at": {
        "type": "date"
      }
    }
  }
}
```

**Успешный ответ:**
```shell
{
  "acknowledged" : true,
  "shards_acknowledged" : true,
  "index" : "user"
}
```

Если попытаться создать уже существующий индекс, то возникнет ошибка. Ошибка тоже имеет формат JSON и достаточно информации, чтобы понять в чём проблема.

**Ответ с инфорацией об ошибке:**
```shell
{
  "error" : {
    "root_cause" : [
      {
        "type" : "resource_already_exists_exception",
        "reason" : "index [user/mYG1G6McTZ2OVqXQSlfrVA] already exists",
        "index_uuid" : "mYG1G6McTZ2OVqXQSlfrVA",
        "index" : "user"
      }
    ],
    "type" : "resource_already_exists_exception",
    "reason" : "index [user/mYG1G6McTZ2OVqXQSlfrVA] already exists",
    "index_uuid" : "mYG1G6McTZ2OVqXQSlfrVA",
    "index" : "user"
  },
  "status" : 400
}
```
### Вывод информации об индексе

- `GET /<index_name>` - общая информация;
- `GET /<index_name>/_mapping` - структура документа;
- `GET /<index_name>/_stats` - обширная информация (есть размер индекса).

**Запросы:**
```
GET /user
GET /user/_mapping
GET /user/_stats
```

### Добавление документа в индекс
```
POST /<index_name>/_doc/<doc_id (optional)>
{<doc>}
```

**Запрос:**
```shell
POST /user/_doc/1
{
  "name": "John Doe",
  "age": 30,
  "created_at": "2000-01-01T00:00:00"
}
```

**Ответ:**
```shell
{
  "_index" : "user",
  "_type" : "_doc",
  "_id" : "1",
  "_version" : 1,
  "result" : "created",
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "failed" : 0
  },
  "_seq_no" : 0,
  "_primary_term" : 1
}
```

В ответе видим **\_version** - версия документа, инкрементируется при обновлении. **result** - название операции, которая была произведена с документом. При первом добавлении в result выводится **created**. Если мы выполним запрос второй раз, то увеличится значение \_version на 1, и result будет **updated**.

Таким образом понимаем, что данный запрос не только добавляет новый документ, но также и обновляет его. Но для обновления необходимо передать полный документ (со всеми полями).

В ElasticSearch есть операции **create** (создание документа, если нет в индексе, иначе ошибка); **update** (обновление документа, если он в индексе, иначе ошибка), **index** (выбор между create и update в зависимости от наличия документа в индексе). В Python названия операций соответствуют названиям методов, и там удобнее всего использовать метод index.

### Добавление множества докуметов

```shell
POST /<index_name>/_bulk
{<meta>}
{<doc>}
...
```
В **\_bulk** можно передать набор различных операций: create, update, index и т.д. И обращаться к различным индексам в одном запросе.

**Запрос:**
```shell
POST /user/_bulk
{"index": {"_index": "user", "_id": "1" }}
{"name": "Kale Smith", "age" : 19, "created_at": "2022-01-01T00:00:00"}
{"index": {"_index": "user", "_id": "2" }}
{"name": "John Blake", "age" : 25, "created_at": "2022-02-01T00:00:00"}
{"index": {"_index": "user", "_id": "3" }}
{"name": "Raul Perez", "age" : 31, "created_at": "2022-03-01T00:00:00"}
{"index": {"_index": "user", "_id": "4" }}
{"name": "Tony Walker", "age" : 44, "created_at": "2022-04-01T00:00:00"}
{"index": {"_index": "user", "_id": "5"}}
{"name": "Justin Blake", "age": 59, "created_at": "2022-05-01T00:00:00"}
```
В первой строчки тела запроса в первом слове **index** указывает название операции. В ответе получим список результатов на каждую операцию. Если некоторые операции выполнились с ошибой, информация об этом будет в списке.

### Динамическое создание индекса

Если добавить документ в несуществующий индекс, то он автоматически создастся, и подгонит структуру под переданный документ.

На момент выполнения запроса индекса **clients** не существует. При выполнении запросов не возникнет ошибок.

**Запросы:**
```shell
POST /clients/_doc/1
{
  "name": "John Smith",
  "age": 19,
  "created_at": "2000-01-01T00:00:00"
}
  
GET /_cat/indices
GET /clients
```

Последняя команда покажет, что индекс уже существует и выведет информацию о структуре документа индекса. Можно будет заметить, 
что ElasticSearch выбирает какие-то типы по-умолчанию, и они в данном случае не оптимальны. Так как полю **age** создан тип **long**, а мы не собираемся хранить там значения более 255, поэтому лучше подойдёт тип **short**. Удобнее создавать индекс автоматически, но для оптимизации, всё же лучше вручную.

### Динамическая структура документа

Если в документе указать несуществующие поля, то они автоматически добавятся в структуру документа индекса. Добавился **location**, которого до этого не было.

**Запрос:**
```shell
POST /clients/_doc/1
{
  "name": "John Smith",
  "age": 19,
  "created_at": "2000-01-01T00:00:00",
  "location": "London"
}

GET /clients/_mapping
```

После выполнения, это поле добавится в структуру документа и индекс.

Динамическое изменение индекса может быть неприятным, если при индексации не сильно обращаем внимание на валидацию передаваемых данных. Для того, чтобы отключить динамическое изменение, необходимо в настройки mapping добавить **"dynamic": false** при создании индекса. При dynamic false несуществующие поля буду игнорироваться.

**Запрос:**
```shell
PUT /clients
{
  "settings": {
    "number_of_shards": 1,
    "number_of_replicas": 0
  },
  "mappings": {
    "dynamic": false,
    "properties": {
      "name": {
        "type": "text"
      }
    }
  }
}
```

### Удаление индекса

```
DELETE /<index_name>
```
С этим запросом необходимо быть осторожным, потому что восстановить данные будет либо очень сложно, либо невозможно. Он удалит индекс и все данные.
```
DELETE /clients
```

### Обновление документа

```
POST /<index_name>/_update/<doc_id>
{<body>}
```
Не обязательно передавать весь документ. Если документа нет в индексе, то ошибка 404. Если документ не был изменен, потому что поле и так равно передаваемому значению, то в result будет "noop" - no operation.

**Запрос:**
```shell
POST /user/_update/1
{
  "doc": {
    "age": 50,
    "name": "Kale Smith"
  }
}
```

### Удаление документа

```
DELETE /<index_name>/_doc/<doc_id>
```

**Запрос:**
```
DELETE /user/_doc/3
```

Попробуйте выполнить один и тот же запрос несколько раз и заметите, что счётчик версии увеличивается. Дело в том, что счётчик закреплен за \_id. И если создать новый документ с ID, который ранее был удален, то версия не обнулится, а продолжит нарастать.

### Запрос документа по ID

```
GET /<index_name>/_doc/<doc_id>
```

**Запрос:**
```
GET /user/_doc/1
```

**Ответ:**
```shell
{
  "_index" : "user",
  "_type" : "_doc",
  "_id" : "1",
  "_version" : 3,
  "_seq_no" : 5,
  "_primary_term" : 1,
  "found" : true,
  "_source" : {
    "name" : "Kale Smith",
    "age" : 19,
    "created_at" : "2022-01-01T00:00:00"
  }
}
```

Чтобы избавиться от оверхеда, можно воспользоваться параметрами **\_source**.

**Запросы:**
```
GET /user/_doc/1/_source
GET /user/_doc/1/_source/?_source=name,age
```

В первом случае получим только данные документа, во втором - только имя и возраст.


## Поиск

```
GET /<index_name>/_search
{<body (optional)>}
```

Все запросы поиска отдают максимум 10000 документов. Но есть техники пагинации и скроллинга, которые позволяют получить больше, используя несколько запросов. Это понадобится, если необходимо сделать выгрузку данных, например, более 10000.

Статья об этом: https://opster.com/guides/elasticsearch/how-tos/elasticsearch-pagination-techniques/

### Вывод всех документов индекса

**Запрос:**
```
GET /user/_search
```

**Ответ:**
```shell
{
  "took" : 16,
  "timed_out" : false,
  "_shards" : {
    "total" : 2,
    "successful" : 2,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 5,
      "relation" : "eq"
    },
    "max_score" : 1.0,
    "hits" : [
      {
        "_index" : "user",
        "_type" : "_doc",
        "_id" : "1",
        "_score" : 1.0,
        "_source" : {
          "name" : "Kale Smith",
          "age" : 19,
          "created_at" : "2022-01-01T00:00:00"
        }
      },
      {
        "_index" : "user",
        "_type" : "_doc",
        "_id" : "2",
        "_score" : 1.0,
        "_source" : {
          "name" : "John Blake",
          "age" : 25,
          "created_at" : "2022-02-01T00:00:00"
        }
      },
	  ...
    ]
  }
}
```

**took** - время в мс затраченное на поиск данных на стороне движка ElasticSearch, оно не включает сериализацию, десериализацию, передачу по сети. По ней удобно отслеживать perfomance запроса.

#### offset, limit

from задаёт offset, size - максимальное количество документов для выдачи.

**Запрос:**
```shell
GET /user/_search
{
  "from": 1,
  "size": 2
}
```

### Поиск по числам (диапазоны, больше, меньше, и т.д)

Поиск по числовым диапазонам производится при помощи запроса **range**. В range можно пользоваться привычными параметрами **gt, gte, lt, lte** для указания диапазонов.

Обычно запросы вкладываются в некоторые логические блоки, например тут это **filter**. filter говорит о том, что все документы, которые входят в заданный range, буду включены в результат. Если бы, например, вместо filter был указан **must_not**, тогда документы подходящие под диапазон напротив были бы пропущены. 

**bool** объединяет в одну логическую единицу логические блоки. Виды логические блоки, которые мы рассмотрим далее: **must, filter, should, and must_not**.

```shell
GET /user/_search
{
  "query": {
    "bool": {
      "filter": {
        "range": {
          "age": {
            "gte": 20,
            "lte": 40
          }
        }
      }
    }
  }
}
```

#### Поиск по значению

Для равенства используется слово **term**, если нам надо найти поле, которое равно чему-то конкретному, то используем его. 

**Запрос:**
```shell
GET /user/_search
{
  "query": {
    "term": {
      "age": 44
    }
  }
}
```

В результате получим всех с возрастом 44. Если запрос простой, необязательно вкладывть его в блоки.
  
### Полнотекстовый поиск

**match** - предназначен для полнотекстового поиска. Ищет строки похожие на переданное значение.

**Запрос:**
```shell
GET /user/_search
{
  "query": {
    "match": {
      "name": "blake"
    }
  }
}
```

**Ответ:**
```shell
{
  ...
  "hits" : {
    ...
    "hits" : [
      {
        ...
        "_source" : {
          "name" : "John Blake",
          "age" : 25,
          "created_at" : "2022-02-01T00:00:00"
        }
      },
      {
        ...
        "_source" : {
          "name" : "Justin Blake",
          "age" : 59,
          "created_at" : "2022-05-01T00:00:00"
        }
      }
    ]
  }
}
```

Если передадим полное имя, второй Justin Blake всё равно останется в результате. Потому что он подходит по слову Blake. У документов есть **\_score** значение, которое отражает насколько документ подходит под запрос.

А как тогда найти только John Blake? Если воспользуемся оператором term, то ничего не найдём.

Дело в том, что у поля name тип text, а тип text подходит для полнотекстового поиска, но не для точного сравнения. Также он не подходит для сортировки. Чтобы выполнять точное сравнение по полю name, необходимо в name добавить подтип **keyword**.

**Запросы:**
```shell
GET /user/_mapping
  
DELETE /user
  
PUT /user
{
  "settings": {
    "number_of_shards": 2,
    "number_of_replicas": 0
  },
  "mappings": {
    "properties": {
      "name": {
        "type": "text",
        "fields": {
          "keyword": {
            "type": "keyword"
          }
        }
      },
      "age": {
        "type": "integer"
      },
      "created_at": {
        "type": "date"
      }
    }
  }
}
```

Теперь можем выполнять поиск по полному совпадению, используя созданный подтип, указывая его через точку после имени поля.

**Запрос:**
```shell
GET /user/_search
{
  "query": {
    "term": {
      "name.keyword": "John Blake"
    }
  }
}
```

Подрезюмируем: **text** - для полей по которым будет выполняться полнотекстовый поиск. **keyword** - для полей по которым выполняется полное сравнение или сортировка. Но если нужны обе функции, то создаем необходимый подтип.

### filter

filter предназначен для включения документов в результат по переданным запросам. filter при поиске не тратит ресурсы на скоринг документов (рассчёт значения \_score документа), поэтому запросы через filter выполняются быстрее. Заметьте, что предыдущий match запрос считает \_score, а при выполнении этого \_score будет равен 0. В filter логичнее всего размещать запросы range и term, так как в этих запросах score не важен.

**Запрос:**
```shell
GET /user/_search
{
  "query": {
    "bool": {
      "filter": {
        "term": {
          "name.keyword": "John Blake"
        }
      }
    }
  }
}
```

Выше в filter всего один запрос, поэтому он в фигурных скобках. Если необходимо сделать несколько запросов в блоке, то следует filter делать списком (квадратные скобки) и каждый подзапрос обрамлять в фигурные. Это касается filter и остальных групп.

**Запрос:**
```shell
GET /user/_search
{
  "query": {
    "bool": {
      "filter": [
        {
          "term": {
            "name.keyword": "John Blake"
          }
        },
        {
          "range": {
            "age": {
              "lt": 26
            }
          }
        }
      ]
    }
  }
}
```

### must

**must** - работает точно также, как и filter, только при этом, в must производится скоринг документов. Таким образом, must хорошо годится для match (запросов полнотекстового поиска), где хотелось бы получить самые подходящие документы под запрос.

**Запрос:**
```shell
GET /user/_search
{
  "query": {
    "bool": {
      "must": {
          "match": {
            "name": "Blake"
          }
      }
    }
  }
}
```

### must_not

Работает как filter, только исключает документы, подходящие под запрос, вместо того, чтобы включать.

```shell
GET /user/_search
{
  "query": {
    "bool": {
      "must_not": {
          "match": {
            "name": "Blake"
          }
      }
    }
  }
}
```

### should

Если необходимо найти всех пользователей с именем Blake или Kale, то обычный must запрос не поможет. Потому что must работает, как оператор логического И. Для логического ИЛИ используем **should**.

**Запрос:**
```shell
# name == Blake && name == Kale

GET /user/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "name": "Blake"
          }
        },
        {
          "match": {
            "name": "Kale"
          }
        }
      ]
    }
  }
}
```

 Если в индексе нету пользователя с именем Kale Blake, то в результате ничего не вернётся.

**Запрос:**
```shell
# name == Blake || name == Kale

GET /user/_search
{
  "query": {
    "bool": {
      "should": [
        {
          "match": {
            "name": "Blake"
          }
        },
        {
          "match": {
            "name": "Kale"
          }
        }
      ]
    }
  }
}
```

Вернёт пользователей у которых в имени есть или Kale, или Blake, или оба варианта.

### Составной запрос

Запросы в ElasticSearch могут быть очень сложными, изложенное выше не описывает и 5% процентов всех возможностей. Чтобы лучше разобраться в запросах, надо читать документацию и смотреть примеры запросов.

Рассмотрим простой составной запрос. Из запроса видно, что могут быть вложенные bool, использоваться блоки must, filter, should и другие в одном запросе.

```
name == "Blake" && (age == 19 || age == 59) && (age >= 18 && age <= 100)
```

**Запрос:**
```shell
GET /user/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "name": "Blake"
          }
        },
        {
          "bool": {
            "should": [
              {
                "term": {
                  "age": 19
                }
              },
              {
                "term": {
                  "age": 59
                }
              }
            ]
          }
        }
      ],
      "filter": [
        {
          "range": {
            "age": {
              "gte": 18,
              "lte": 100
            }
          }
        }
      ]
    }
  }
}
```

### Запрос конкретных полей

Если не нужен весь документ, можно убрать оверхед и получать только те поля, которые необходимы, используя \_source.

**Запрос:**
```shell
GET /user/_search
{
  "_source": ["name", "age"],
  "query": {
    "bool": {
      "should": [
        {
          "match": {
            "name": "Blake"
          }
        },
        {
          "match": {
            "name": "Kale"
          }
        }
      ]
    }
  }
}
```

### Сортировка документов

order принимает два значения - asc (по возрастанию) и desc (по убыванию).

**Запрос:**
```shell
GET /user/_search
{
  "_source": ["age"],
  "sort": [
    {
      "age": {
        "order": "desc"
      }
    }
  ]
}
```

Возможна сортировка по нескольким полям одновременно. Заметьте, что для поля name используется подтип keyword, а не просто name, так как при попытке отсортировать по полю с типом text возникнет ошибка.

**Запрос:**
```shell
GET /user/_search
{
  "sort": [
    {
      "age": {
        "order": "asc"
      }
    },
    {
      "name.keyword": {
        "order": "asc"
      }
    }
  ]
}
```

Про сортировку по тексту: https://opster.com/guides/elasticsearch/search-apis/optimizing-elasticsearch-sort-by-text-field/

### Дополнительный материал

- ChatGPT по ElasticSearch (хорошо отвечает на вопросы об ElasticSearch, быстрее, чем искать): https://checkups.opster.com/ops-gpt
- Документация: https://www.elastic.co/guide/en/elasticsearch/reference/current/elasticsearch-intro.html
- Анализаторы: https://mallikarjuna91.medium.com/what-is-tokenizer-analyzer-and-filter-in-elasticsearch-317d4ec69ecc
